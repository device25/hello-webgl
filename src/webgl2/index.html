<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGL2</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
        position: fixed;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // WebGL2 context initialization with error checking
      const canvas = document.getElementById("canvas");
      /** @type {WebGL2RenderingContext} */
      const gl = canvas.getContext("webgl2");
      if (!gl) {
        throw new Error("WebGL2 not supported");
      }

      // Shader source code
      const vertexShaderSource = `#version 300 es
      in vec2 pos;
      in vec3 inColor;

      out vec3 fragColor;

      void main() {
        fragColor = inColor;

        // Coordinates x, y, z.
        // W is the scale factor.
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#homogeneous_coordinates
        gl_Position = vec4(pos.x, -pos.y, 0.0, 1.0);
      }`;
      const fragmentShaderSource = `#version 300 es
      precision highp float;
      in vec3 fragColor;

      out vec4 outColor;

      void main() {
        // rgb alpha
        outColor = vec4(fragColor, 1.0);
      }`;

      // Helper function for shader compilation
      const createShader = (type, source) => {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);

          throw new Error(`Shader compilation failed: ${error}`);
        }

        return shader;
      };

      // Shader compilation
      const vs = createShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

      // Program linking with error checking
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);

        throw new Error(`Program linking failed: ${error}`);
      }

      // Cleanup shaders after linking
      gl.detachShader(program, vs);
      gl.detachShader(program, fs);
      gl.deleteShader(vs);
      gl.deleteShader(fs);

      let vertices = [
        -0.547, -0.785, -0.267, -0.897, -0.013, -0.804, -0.547, -0.785, -0.013,
        -0.804, 0.158, -0.567, -0.547, -0.785, 0.158, -0.567, 0.16, -0.34,
        -0.547, -0.785, 0.16, -0.34, 0.008, -0.131, 0.461, 0.016, 0.779, -0.006,
        0.461, 0.713, 0.008, -0.131, 0.461, 0.016, 0.461, 0.713, -0.547, -0.785,
        0.008, -0.131, 0.461, 0.713, 0.461, 0.713, 0.003, 0.857, -0.44, 0.713,
        0.461, 0.713, -0.44, 0.713, -0.623, 0.358, 0.461, 0.713, -0.623, 0.358,
        -0.438, 0.012, 0.461, 0.713, -0.438, 0.012, -0.272, -0.04, -0.547,
        -0.785, 0.461, 0.713, -0.272, -0.04, -0.547, -0.785, -0.272, -0.04,
        -0.552, -0.137, -0.552, -0.137, -0.794, -0.103, -0.697, -0.302, -0.547,
        -0.785, -0.552, -0.137, -0.697, -0.302, -0.697, -0.302, -0.705, -0.573,
        -0.547, -0.785,
      ];

      let colors = [
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        0.973, 0.514, 0.125, 0.973, 0.514, 0.125, 0.973, 0.514, 0.125,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
        //
        1.0, 0.85, 0.0, 1.0, 0.85, 0.0, 1.0, 0.85, 0.0,
      ];

      // attribute setup
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW,
      );
      const positionAttributeLocation = gl.getAttribLocation(program, "pos");
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(
        positionAttributeLocation,
        2, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      const colorAttributeLocation = gl.getAttribLocation(program, "inColor");
      gl.enableVertexAttribArray(colorAttributeLocation);
      gl.vertexAttribPointer(
        colorAttributeLocation,
        3, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );

      // Cleanup function
      const cleanup = () => {
        gl.deleteBuffer(positionBuffer);
        gl.deleteBuffer(colorBuffer);
        gl.deleteProgram(program);
      };

      // Add cleanup on page unload
      window.addEventListener("unload", cleanup);

      // Render function with error checking
      const render = () => {
        gl.useProgram(program);
        const error = gl.getError();
        if (error !== gl.NO_ERROR) {
          console.error("WebGL error:", error);
          return;
        }
        gl.drawArrays(gl.TRIANGLES, 0, 48);
      };

      // Set up canvas size and viewport
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        gl.viewport(0, 0, canvas.width, canvas.height);
        render();
      };
      window.addEventListener("resize", resize);

      // interaction
      const onMouseClick = (
        /** @type {PointerEvent} */
        event,
      ) => {
        //normalized device coordinates
        const coordinates = [
          (event.clientX / window.innerWidth) * 2 - 1,
          (event.clientY / window.innerHeight) * -2 + 1,
        ];

        // remove first point
        vertices.splice(0, 2);
        // add new point
        vertices.push(...coordinates);

        // re-upload buffer data
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW,
        );

        render();
      };
      window.addEventListener("click", onMouseClick);

      // Initial setup
      resize();
      render();
    </script>
  </body>
</html>
