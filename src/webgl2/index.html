<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGL2</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
        position: fixed;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // WebGL2 context initialization with error checking
      const canvas = document.getElementById("canvas");
      /** @type {WebGL2RenderingContext} */
      const gl = canvas.getContext("webgl2");
      if (!gl) {
        throw new Error("WebGL2 not supported");
      }

      // Shader source code
      const vertexShaderSource = `#version 300 es
      in vec2 pos;
      in vec3 inColor;

      out vec3 fragColor;

      void main() {
        fragColor = inColor;

        // Coordinates x, y, z.
        // W is the scale factor.
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#homogeneous_coordinates
        gl_Position = vec4(pos, 0.0, 1.0);
      }`;
      const fragmentShaderSource = `#version 300 es
      precision highp float;
      in vec3 fragColor;

      out vec4 outColor;

      void main() {
        // rgb alpha
        outColor = vec4(fragColor, 1.0);
      }`;

      // Helper function for shader compilation
      const createShader = (type, source) => {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);

          throw new Error(`Shader compilation failed: ${error}`);
        }

        return shader;
      };

      // Shader compilation
      const vs = createShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

      // Program linking with error checking
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);

        throw new Error(`Program linking failed: ${error}`);
      }

      // Cleanup shaders after linking
      gl.detachShader(program, vs);
      gl.detachShader(program, fs);
      gl.deleteShader(vs);
      gl.deleteShader(fs);

      let vertices = [
        // first triangle
        // first vertex
        -1.0, -1.0,
        // second vertex
        1.0, -1.0,
        // third vertex
        -1.0, 1.0,
        // second triangle
        // first vertex
        1.0, 1.0,
        // second vertex
        1.0, -1.0,
        // third vertex
        -1.0, 1.0,
      ];

      let colors = [
        // first triangle
        // first vertex
        1.0, 0.85, 0.0,
        // second vertex
        1.0, 0.85, 0.0,
        // third vertex
        1.0, 0.85, 0.0,
        // second triangle
        // first vertex
        0.76, 0.98, 0.96,
        // second vertex
        0.76, 0.98, 0.96,
        // third vertex
        0.76, 0.98, 0.96,
      ];

      // attribute setup
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW,
      );
      const positionAttributeLocation = gl.getAttribLocation(program, "pos");
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(
        positionAttributeLocation,
        2, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      const colorAttributeLocation = gl.getAttribLocation(program, "inColor");
      gl.enableVertexAttribArray(colorAttributeLocation);
      gl.vertexAttribPointer(
        colorAttributeLocation,
        3, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );

      // Cleanup function
      const cleanup = () => {
        gl.deleteBuffer(positionBuffer);
        gl.deleteBuffer(colorBuffer);
        gl.deleteProgram(program);
      };

      // Add cleanup on page unload
      window.addEventListener("unload", cleanup);

      // Render function with error checking
      const render = () => {
        gl.useProgram(program);
        const error = gl.getError();
        if (error !== gl.NO_ERROR) {
          console.error("WebGL error:", error);
          return;
        }
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      };

      // Set up canvas size and viewport
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        gl.viewport(0, 0, canvas.width, canvas.height);
        render();
      };
      window.addEventListener("resize", resize);

      // interaction
      const onMouseClick = (
        /** @type {PointerEvent} */
        event,
      ) => {
        //normalized device coordinates
        const coordinates = [
          (event.clientX / window.innerWidth) * 2 - 1,
          (event.clientY / window.innerHeight) * -2 + 1,
        ];

        // remove first point
        vertices.splice(0, 2);
        // add new point
        vertices.push(...coordinates);

        // re-upload buffer data
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW,
        );

        render();
      };
      window.addEventListener("click", onMouseClick);

      // Initial setup
      resize();
      render();
    </script>
  </body>
</html>
