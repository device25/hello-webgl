<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGL2</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
        position: fixed;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // Get WebGL2 context
      const canvas = document.getElementById("canvas");
      /** @type {WebGL2RenderingContext} gl */
      const gl = canvas.getContext("webgl2");

      // Shader compilation
      const vertexShaderSource = `#version 300 es
      in vec2 pos;
      in float size;

      void main() {
        // Coordinates x, y, z.
        // W is the scale factor.
        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#homogeneous_coordinates
        gl_Position = vec4(pos, 0.0, 1.0);
        gl_PointSize = size;
      }`;
      const fragmentShaderSource = `#version 300 es
      precision highp float;
      out vec4 outColor;

      void main() {
        outColor = vec4(1.0, 0.0, 0.0, 1.0);
      }`;
      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, vertexShaderSource);
      gl.compileShader(vs);
      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
        console.error(
          "Vertex shader failed to compile:",
          gl.getShaderInfoLog(vs),
        );
      }
      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, fragmentShaderSource);
      gl.compileShader(fs);
      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
        console.error(
          "Fragment shader failed to compile:",
          gl.getShaderInfoLog(fs),
        );
      }

      // Program linking
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program failed to link:", gl.getProgramInfoLog(program));
      }

      // attribute setup
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([0.0, 0.0]),
        gl.STATIC_DRAW,
      );
      const positionAttributeLocation = gl.getAttribLocation(program, "pos");
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(
        positionAttributeLocation,
        2, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );
      const sizeBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([50.0]), gl.STATIC_DRAW);
      const sizeAttributeLocation = gl.getAttribLocation(program, "size");
      gl.enableVertexAttribArray(sizeAttributeLocation);
      gl.vertexAttribPointer(
        sizeAttributeLocation,
        1, // size (num components)
        gl.FLOAT, // type of data in buffer
        false, // normalize
        0, // stride (0 = auto)
        0, // offset
      );

      // Render function
      const render = () => {
        gl.useProgram(program);
        gl.drawArrays(gl.POINTS, 0, 1);
      };

      // Set up canvas size and viewport
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        gl.viewport(0, 0, canvas.width, canvas.height);
        render();
      };
      window.addEventListener("resize", resize);

      // interaction
      const onMouseMove = () => {
        // check if mouse is pressed
        if (window.event.buttons !== 1) {
          return;
        }

        //normalized device coordinates
        const coordinates = [
          (window.event.clientX / window.innerWidth) * 2 - 1,
          (window.event.clientY / window.innerHeight) * -2 + 1,
        ];

        // Calculate distance from center (0,0) to determine point size
        // formula: distance = sqrt(x^2 + y^2)
        const distance = Math.sqrt(
          coordinates[0] * coordinates[0] + coordinates[1] * coordinates[1],
        );
        // Size decreases as point moves away from center
        // Max size 50, min size 0
        const size = (1 - distance) * 50;

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(coordinates),
          gl.STATIC_DRAW,
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([size]),
          gl.STATIC_DRAW,
        );
        render();
      };
      window.addEventListener("mousemove", onMouseMove);

      // Initial setup
      resize();
      render();
    </script>
  </body>
</html>
